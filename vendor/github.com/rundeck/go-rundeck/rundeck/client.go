// Package rundeck implements the Azure ARM Rundeck service API version 1.0.0.
//
//
package rundeck

// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

import (
    "context"
    "github.com/Azure/go-autorest/autorest"
    "github.com/Azure/go-autorest/autorest/azure"
    "github.com/Azure/go-autorest/autorest/validation"
    "github.com/Azure/go-autorest/tracing"
    "io"
    "net/http"
)

const (
// DefaultBaseURI is the default URI used for the service Rundeck
DefaultBaseURI = "/api/26")

// BaseClient is the base client for Rundeck.
type BaseClient struct {
    autorest.Client
    BaseURI string
}

// New creates an instance of the BaseClient client.
func New()BaseClient {
    return NewWithBaseURI(DefaultBaseURI, )
}

// NewWithBaseURI creates an instance of the BaseClient client.
func NewWithBaseURI(baseURI string, ) BaseClient {
    return BaseClient{
        Client: autorest.NewClientWithUserAgent(UserAgent()),
        BaseURI: baseURI,
    }
}

    // ExecutionBulkDelete sends the execution bulk delete request.
    func (client BaseClient) ExecutionBulkDelete(ctx context.Context, executionBulkDeleteRequest ExecutionBulkDeleteRequest) (result JobExecutionDelete, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ExecutionBulkDelete")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: executionBulkDeleteRequest,
                 Constraints: []validation.Constraint{	{Target: "executionBulkDeleteRequest.Ids", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
                return result, validation.NewError("rundeck.BaseClient", "ExecutionBulkDelete", err.Error())
                }

                    req, err := client.ExecutionBulkDeletePreparer(ctx, executionBulkDeleteRequest)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ExecutionBulkDelete", nil , "Failure preparing request")
        return
        }

                resp, err := client.ExecutionBulkDeleteSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ExecutionBulkDelete", resp, "Failure sending request")
                return
                }

                result, err = client.ExecutionBulkDeleteResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ExecutionBulkDelete", resp, "Failure responding to request")
                }

        return
        }

        // ExecutionBulkDeletePreparer prepares the ExecutionBulkDelete request.
        func (client BaseClient) ExecutionBulkDeletePreparer(ctx context.Context, executionBulkDeleteRequest ExecutionBulkDeleteRequest) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/executions/delete"),
        autorest.WithJSON(executionBulkDeleteRequest))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ExecutionBulkDeleteSender sends the ExecutionBulkDelete request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ExecutionBulkDeleteSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ExecutionBulkDeleteResponder handles the response to the ExecutionBulkDelete request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ExecutionBulkDeleteResponder(resp *http.Response) (result JobExecutionDelete, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // ExecutionDelete sends the execution delete request.
    func (client BaseClient) ExecutionDelete(ctx context.Context, ID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ExecutionDelete")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ExecutionDeletePreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ExecutionDelete", nil , "Failure preparing request")
        return
        }

                resp, err := client.ExecutionDeleteSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ExecutionDelete", resp, "Failure sending request")
                return
                }

                result, err = client.ExecutionDeleteResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ExecutionDelete", resp, "Failure responding to request")
                }

        return
        }

        // ExecutionDeletePreparer prepares the ExecutionDelete request.
        func (client BaseClient) ExecutionDeletePreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/execution/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ExecutionDeleteSender sends the ExecutionDelete request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ExecutionDeleteSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ExecutionDeleteResponder handles the response to the ExecutionDelete request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ExecutionDeleteResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // ExecutionInputFilesList sends the execution input files list request.
    func (client BaseClient) ExecutionInputFilesList(ctx context.Context, ID string) (result ExecutionInputFilesListOKResponse, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ExecutionInputFilesList")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ExecutionInputFilesListPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ExecutionInputFilesList", nil , "Failure preparing request")
        return
        }

                resp, err := client.ExecutionInputFilesListSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ExecutionInputFilesList", resp, "Failure sending request")
                return
                }

                result, err = client.ExecutionInputFilesListResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ExecutionInputFilesList", resp, "Failure responding to request")
                }

        return
        }

        // ExecutionInputFilesListPreparer prepares the ExecutionInputFilesList request.
        func (client BaseClient) ExecutionInputFilesListPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/execution/{id}/input/files",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ExecutionInputFilesListSender sends the ExecutionInputFilesList request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ExecutionInputFilesListSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ExecutionInputFilesListResponder handles the response to the ExecutionInputFilesList request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ExecutionInputFilesListResponder(resp *http.Response) (result ExecutionInputFilesListOKResponse, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // ExecutionListRunning sends the execution list running request.
        // Parameters:
            // project - project name or * for all projects
    func (client BaseClient) ExecutionListRunning(ctx context.Context, project string) (result ExecutionList, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ExecutionListRunning")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ExecutionListRunningPreparer(ctx, project)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ExecutionListRunning", nil , "Failure preparing request")
        return
        }

                resp, err := client.ExecutionListRunningSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ExecutionListRunning", resp, "Failure sending request")
                return
                }

                result, err = client.ExecutionListRunningResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ExecutionListRunning", resp, "Failure responding to request")
                }

        return
        }

        // ExecutionListRunningPreparer prepares the ExecutionListRunning request.
        func (client BaseClient) ExecutionListRunningPreparer(ctx context.Context, project string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "project": autorest.Encode("path",project),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/project/{project}/executions/running",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ExecutionListRunningSender sends the ExecutionListRunning request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ExecutionListRunningSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ExecutionListRunningResponder handles the response to the ExecutionListRunning request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ExecutionListRunningResponder(resp *http.Response) (result ExecutionList, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // ExecutionQuery sends the execution query request.
        // Parameters:
            // statusFilter -
            // abortedbyFilter - username who aborted an execution
            // userFilter - username who started the execution
            // recentFilter - use a simple text format to filter executions that completed within a period of time. The
            // format is “XY” where X is an integer, and “Y” is one of:
            // * h: hour
            // * d: day
            // olderFilter - (same format as recentFilter) return executions that completed before the specified relative
            // period of time
            // begin - specify exact date for earliest execution completion time
    func (client BaseClient) ExecutionQuery(ctx context.Context, project string, statusFilter string, abortedbyFilter string, userFilter string, recentFilter string, olderFilter string, begin string, adhoc *bool) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ExecutionQuery")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ExecutionQueryPreparer(ctx, project, statusFilter, abortedbyFilter, userFilter, recentFilter, olderFilter, begin, adhoc)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ExecutionQuery", nil , "Failure preparing request")
        return
        }

                resp, err := client.ExecutionQuerySender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ExecutionQuery", resp, "Failure sending request")
                return
                }

                result, err = client.ExecutionQueryResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ExecutionQuery", resp, "Failure responding to request")
                }

        return
        }

        // ExecutionQueryPreparer prepares the ExecutionQuery request.
        func (client BaseClient) ExecutionQueryPreparer(ctx context.Context, project string, statusFilter string, abortedbyFilter string, userFilter string, recentFilter string, olderFilter string, begin string, adhoc *bool) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "project": autorest.Encode("path",project),
                }

                        queryParameters := map[string]interface{} {
            }
                if len(string(statusFilter)) > 0 {
                queryParameters["statusFilter"] = autorest.Encode("query",statusFilter)
                }
                if len(abortedbyFilter) > 0 {
                queryParameters["abortedbyFilter"] = autorest.Encode("query",abortedbyFilter)
                }
                if len(userFilter) > 0 {
                queryParameters["userFilter"] = autorest.Encode("query",userFilter)
                }
                if len(recentFilter) > 0 {
                queryParameters["recentFilter"] = autorest.Encode("query",recentFilter)
                }
                if len(olderFilter) > 0 {
                queryParameters["olderFilter"] = autorest.Encode("query",olderFilter)
                }
                if len(begin) > 0 {
                queryParameters["begin"] = autorest.Encode("query",begin)
                }
                if adhoc != nil {
                queryParameters["adhoc"] = autorest.Encode("query",*adhoc)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/project/{project}/executions",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ExecutionQuerySender sends the ExecutionQuery request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ExecutionQuerySender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ExecutionQueryResponder handles the response to the ExecutionQuery request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ExecutionQueryResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // ExecutionStateGet sends the execution state get request.
    func (client BaseClient) ExecutionStateGet(ctx context.Context, ID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ExecutionStateGet")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ExecutionStateGetPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ExecutionStateGet", nil , "Failure preparing request")
        return
        }

                resp, err := client.ExecutionStateGetSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ExecutionStateGet", resp, "Failure sending request")
                return
                }

                result, err = client.ExecutionStateGetResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ExecutionStateGet", resp, "Failure responding to request")
                }

        return
        }

        // ExecutionStateGetPreparer prepares the ExecutionStateGet request.
        func (client BaseClient) ExecutionStateGetPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/execution/{id}/state",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ExecutionStateGetSender sends the ExecutionStateGet request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ExecutionStateGetSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ExecutionStateGetResponder handles the response to the ExecutionStateGet request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ExecutionStateGetResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // ExecutionStatusGet sends the execution status get request.
    func (client BaseClient) ExecutionStatusGet(ctx context.Context, ID string) (result Execution, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ExecutionStatusGet")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ExecutionStatusGetPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ExecutionStatusGet", nil , "Failure preparing request")
        return
        }

                resp, err := client.ExecutionStatusGetSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ExecutionStatusGet", resp, "Failure sending request")
                return
                }

                result, err = client.ExecutionStatusGetResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ExecutionStatusGet", resp, "Failure responding to request")
                }

        return
        }

        // ExecutionStatusGetPreparer prepares the ExecutionStatusGet request.
        func (client BaseClient) ExecutionStatusGetPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/execution/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ExecutionStatusGetSender sends the ExecutionStatusGet request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ExecutionStatusGetSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ExecutionStatusGetResponder handles the response to the ExecutionStatusGet request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ExecutionStatusGetResponder(resp *http.Response) (result Execution, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // JobBulkDelete sends the job bulk delete request.
    func (client BaseClient) JobBulkDelete(ctx context.Context, jobBulkDeleteRequest JobBulkDeleteRequest) (result JobBulkOperationResponse, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.JobBulkDelete")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: jobBulkDeleteRequest,
                 Constraints: []validation.Constraint{	{Target: "jobBulkDeleteRequest.Ids", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
                return result, validation.NewError("rundeck.BaseClient", "JobBulkDelete", err.Error())
                }

                    req, err := client.JobBulkDeletePreparer(ctx, jobBulkDeleteRequest)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobBulkDelete", nil , "Failure preparing request")
        return
        }

                resp, err := client.JobBulkDeleteSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobBulkDelete", resp, "Failure sending request")
                return
                }

                result, err = client.JobBulkDeleteResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobBulkDelete", resp, "Failure responding to request")
                }

        return
        }

        // JobBulkDeletePreparer prepares the JobBulkDelete request.
        func (client BaseClient) JobBulkDeletePreparer(ctx context.Context, jobBulkDeleteRequest JobBulkDeleteRequest) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/jobs/delete"),
        autorest.WithJSON(jobBulkDeleteRequest))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // JobBulkDeleteSender sends the JobBulkDelete request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) JobBulkDeleteSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // JobBulkDeleteResponder handles the response to the JobBulkDelete request. The method always
    // closes the http.Response Body.
    func (client BaseClient) JobBulkDeleteResponder(resp *http.Response) (result JobBulkOperationResponse, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // JobDelete sends the job delete request.
        // Parameters:
            // ID - ID of job to delete.
    func (client BaseClient) JobDelete(ctx context.Context, ID string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.JobDelete")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.JobDeletePreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobDelete", nil , "Failure preparing request")
        return
        }

                resp, err := client.JobDeleteSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobDelete", resp, "Failure sending request")
                return
                }

                result, err = client.JobDeleteResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobDelete", resp, "Failure responding to request")
                }

        return
        }

        // JobDeletePreparer prepares the JobDelete request.
        func (client BaseClient) JobDeletePreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/job/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // JobDeleteSender sends the JobDelete request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) JobDeleteSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // JobDeleteResponder handles the response to the JobDelete request. The method always
    // closes the http.Response Body.
    func (client BaseClient) JobDeleteResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusNotFound),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // JobExecutionBulkDisable sends the job execution bulk disable request.
    func (client BaseClient) JobExecutionBulkDisable(ctx context.Context, jobExecutionBulkDisableRequest JobExecutionBulkDisableRequest) (result JobBulkOperationResponse, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.JobExecutionBulkDisable")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: jobExecutionBulkDisableRequest,
                 Constraints: []validation.Constraint{	{Target: "jobExecutionBulkDisableRequest.Ids", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
                return result, validation.NewError("rundeck.BaseClient", "JobExecutionBulkDisable", err.Error())
                }

                    req, err := client.JobExecutionBulkDisablePreparer(ctx, jobExecutionBulkDisableRequest)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobExecutionBulkDisable", nil , "Failure preparing request")
        return
        }

                resp, err := client.JobExecutionBulkDisableSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobExecutionBulkDisable", resp, "Failure sending request")
                return
                }

                result, err = client.JobExecutionBulkDisableResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobExecutionBulkDisable", resp, "Failure responding to request")
                }

        return
        }

        // JobExecutionBulkDisablePreparer prepares the JobExecutionBulkDisable request.
        func (client BaseClient) JobExecutionBulkDisablePreparer(ctx context.Context, jobExecutionBulkDisableRequest JobExecutionBulkDisableRequest) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/jobs/execution/disable"),
        autorest.WithJSON(jobExecutionBulkDisableRequest))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // JobExecutionBulkDisableSender sends the JobExecutionBulkDisable request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) JobExecutionBulkDisableSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // JobExecutionBulkDisableResponder handles the response to the JobExecutionBulkDisable request. The method always
    // closes the http.Response Body.
    func (client BaseClient) JobExecutionBulkDisableResponder(resp *http.Response) (result JobBulkOperationResponse, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // JobExecutionBulkEnable sends the job execution bulk enable request.
    func (client BaseClient) JobExecutionBulkEnable(ctx context.Context, jobExecutionBulkEnableRequest JobExecutionBulkEnableRequest) (result JobBulkOperationResponse, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.JobExecutionBulkEnable")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: jobExecutionBulkEnableRequest,
                 Constraints: []validation.Constraint{	{Target: "jobExecutionBulkEnableRequest.Ids", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
                return result, validation.NewError("rundeck.BaseClient", "JobExecutionBulkEnable", err.Error())
                }

                    req, err := client.JobExecutionBulkEnablePreparer(ctx, jobExecutionBulkEnableRequest)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobExecutionBulkEnable", nil , "Failure preparing request")
        return
        }

                resp, err := client.JobExecutionBulkEnableSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobExecutionBulkEnable", resp, "Failure sending request")
                return
                }

                result, err = client.JobExecutionBulkEnableResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobExecutionBulkEnable", resp, "Failure responding to request")
                }

        return
        }

        // JobExecutionBulkEnablePreparer prepares the JobExecutionBulkEnable request.
        func (client BaseClient) JobExecutionBulkEnablePreparer(ctx context.Context, jobExecutionBulkEnableRequest JobExecutionBulkEnableRequest) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/jobs/execution/enable"),
        autorest.WithJSON(jobExecutionBulkEnableRequest))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // JobExecutionBulkEnableSender sends the JobExecutionBulkEnable request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) JobExecutionBulkEnableSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // JobExecutionBulkEnableResponder handles the response to the JobExecutionBulkEnable request. The method always
    // closes the http.Response Body.
    func (client BaseClient) JobExecutionBulkEnableResponder(resp *http.Response) (result JobBulkOperationResponse, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // JobExecutionDeleteMethod sends the job execution delete method request.
        // Parameters:
            // ID - job ID
    func (client BaseClient) JobExecutionDeleteMethod(ctx context.Context, ID int32) (result JobExecutionDelete, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.JobExecutionDeleteMethod")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.JobExecutionDeleteMethodPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobExecutionDeleteMethod", nil , "Failure preparing request")
        return
        }

                resp, err := client.JobExecutionDeleteMethodSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobExecutionDeleteMethod", resp, "Failure sending request")
                return
                }

                result, err = client.JobExecutionDeleteMethodResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobExecutionDeleteMethod", resp, "Failure responding to request")
                }

        return
        }

        // JobExecutionDeleteMethodPreparer prepares the JobExecutionDeleteMethod request.
        func (client BaseClient) JobExecutionDeleteMethodPreparer(ctx context.Context, ID int32) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/job/{id}/executions",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // JobExecutionDeleteMethodSender sends the JobExecutionDeleteMethod request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) JobExecutionDeleteMethodSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // JobExecutionDeleteMethodResponder handles the response to the JobExecutionDeleteMethod request. The method always
    // closes the http.Response Body.
    func (client BaseClient) JobExecutionDeleteMethodResponder(resp *http.Response) (result JobExecutionDelete, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // JobExecutionDisable sends the job execution disable request.
    func (client BaseClient) JobExecutionDisable(ctx context.Context, ID string) (result JobExecutionDisableOKResponse, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.JobExecutionDisable")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.JobExecutionDisablePreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobExecutionDisable", nil , "Failure preparing request")
        return
        }

                resp, err := client.JobExecutionDisableSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobExecutionDisable", resp, "Failure sending request")
                return
                }

                result, err = client.JobExecutionDisableResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobExecutionDisable", resp, "Failure responding to request")
                }

        return
        }

        // JobExecutionDisablePreparer prepares the JobExecutionDisable request.
        func (client BaseClient) JobExecutionDisablePreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/job/{id}/execution/disable",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // JobExecutionDisableSender sends the JobExecutionDisable request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) JobExecutionDisableSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // JobExecutionDisableResponder handles the response to the JobExecutionDisable request. The method always
    // closes the http.Response Body.
    func (client BaseClient) JobExecutionDisableResponder(resp *http.Response) (result JobExecutionDisableOKResponse, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // JobExecutionEnable sends the job execution enable request.
    func (client BaseClient) JobExecutionEnable(ctx context.Context, ID string) (result JobExecutionEnableOKResponse, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.JobExecutionEnable")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.JobExecutionEnablePreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobExecutionEnable", nil , "Failure preparing request")
        return
        }

                resp, err := client.JobExecutionEnableSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobExecutionEnable", resp, "Failure sending request")
                return
                }

                result, err = client.JobExecutionEnableResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobExecutionEnable", resp, "Failure responding to request")
                }

        return
        }

        // JobExecutionEnablePreparer prepares the JobExecutionEnable request.
        func (client BaseClient) JobExecutionEnablePreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/job/{id}/execution/enable",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // JobExecutionEnableSender sends the JobExecutionEnable request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) JobExecutionEnableSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // JobExecutionEnableResponder handles the response to the JobExecutionEnable request. The method always
    // closes the http.Response Body.
    func (client BaseClient) JobExecutionEnableResponder(resp *http.Response) (result JobExecutionEnableOKResponse, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // JobExecutionList sends the job execution list request.
        // Parameters:
            // ID - job ID
    func (client BaseClient) JobExecutionList(ctx context.Context, ID string) (result ExecutionList, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.JobExecutionList")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.JobExecutionListPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobExecutionList", nil , "Failure preparing request")
        return
        }

                resp, err := client.JobExecutionListSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobExecutionList", resp, "Failure sending request")
                return
                }

                result, err = client.JobExecutionListResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobExecutionList", resp, "Failure responding to request")
                }

        return
        }

        // JobExecutionListPreparer prepares the JobExecutionList request.
        func (client BaseClient) JobExecutionListPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/job/{id}/executions",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // JobExecutionListSender sends the JobExecutionList request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) JobExecutionListSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // JobExecutionListResponder handles the response to the JobExecutionList request. The method always
    // closes the http.Response Body.
    func (client BaseClient) JobExecutionListResponder(resp *http.Response) (result ExecutionList, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // JobExecutionRun sends the job execution run request.
        // Parameters:
            // ID - job ID
    func (client BaseClient) JobExecutionRun(ctx context.Context, ID int32, request *ExecuteJobRequest) (result ExecutionList, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.JobExecutionRun")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.JobExecutionRunPreparer(ctx, ID, request)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobExecutionRun", nil , "Failure preparing request")
        return
        }

                resp, err := client.JobExecutionRunSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobExecutionRun", resp, "Failure sending request")
                return
                }

                result, err = client.JobExecutionRunResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobExecutionRun", resp, "Failure responding to request")
                }

        return
        }

        // JobExecutionRunPreparer prepares the JobExecutionRun request.
        func (client BaseClient) JobExecutionRunPreparer(ctx context.Context, ID int32, request *ExecuteJobRequest) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/job/{id}/executions",pathParameters))
                if request != nil {
                preparer = autorest.DecoratePreparer(preparer,
                autorest.WithJSON(request))
                }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // JobExecutionRunSender sends the JobExecutionRun request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) JobExecutionRunSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // JobExecutionRunResponder handles the response to the JobExecutionRun request. The method always
    // closes the http.Response Body.
    func (client BaseClient) JobExecutionRunResponder(resp *http.Response) (result ExecutionList, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // JobGet sends the job get request.
        // Parameters:
            // ID - ID of the job to export.
            // formatParameter -
    func (client BaseClient) JobGet(ctx context.Context, ID string, formatParameter string) (result ReadCloser, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.JobGet")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.JobGetPreparer(ctx, ID, formatParameter)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobGet", nil , "Failure preparing request")
        return
        }

                resp, err := client.JobGetSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobGet", resp, "Failure sending request")
                return
                }

                result, err = client.JobGetResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobGet", resp, "Failure responding to request")
                }

        return
        }

        // JobGetPreparer prepares the JobGet request.
        func (client BaseClient) JobGetPreparer(ctx context.Context, ID string, formatParameter string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            }
                if len(string(formatParameter)) > 0 {
                queryParameters["format"] = autorest.Encode("query",formatParameter)
                    } else {
                    queryParameters["format"] = autorest.Encode("query","xml")
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/job/{id}",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // JobGetSender sends the JobGet request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) JobGetSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // JobGetResponder handles the response to the JobGet request. The method always
    // closes the http.Response Body.
    func (client BaseClient) JobGetResponder(resp *http.Response) (result ReadCloser, err error) {
        result.Value = &resp.Body
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound))
        result.Response = autorest.Response{Response: resp}
            return
        }

    // JobInfoGet sends the job info get request.
    func (client BaseClient) JobInfoGet(ctx context.Context, ID string) (result JobMetadata, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.JobInfoGet")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.JobInfoGetPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobInfoGet", nil , "Failure preparing request")
        return
        }

                resp, err := client.JobInfoGetSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobInfoGet", resp, "Failure sending request")
                return
                }

                result, err = client.JobInfoGetResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobInfoGet", resp, "Failure responding to request")
                }

        return
        }

        // JobInfoGetPreparer prepares the JobInfoGet request.
        func (client BaseClient) JobInfoGetPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/job/{id}/info",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // JobInfoGetSender sends the JobInfoGet request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) JobInfoGetSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // JobInfoGetResponder handles the response to the JobInfoGet request. The method always
    // closes the http.Response Body.
    func (client BaseClient) JobInfoGetResponder(resp *http.Response) (result JobMetadata, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // JobInputFileInfoGet sends the job input file info get request.
    func (client BaseClient) JobInputFileInfoGet(ctx context.Context, ID string) (result JobInputFileInfo, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.JobInputFileInfoGet")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.JobInputFileInfoGetPreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobInputFileInfoGet", nil , "Failure preparing request")
        return
        }

                resp, err := client.JobInputFileInfoGetSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobInputFileInfoGet", resp, "Failure sending request")
                return
                }

                result, err = client.JobInputFileInfoGetResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobInputFileInfoGet", resp, "Failure responding to request")
                }

        return
        }

        // JobInputFileInfoGetPreparer prepares the JobInputFileInfoGet request.
        func (client BaseClient) JobInputFileInfoGetPreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/jobs/file/{id}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // JobInputFileInfoGetSender sends the JobInputFileInfoGet request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) JobInputFileInfoGetSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // JobInputFileInfoGetResponder handles the response to the JobInputFileInfoGet request. The method always
    // closes the http.Response Body.
    func (client BaseClient) JobInputFileInfoGetResponder(resp *http.Response) (result JobInputFileInfo, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // JobInputFileUpload sends the job input file upload request.
    func (client BaseClient) JobInputFileUpload(ctx context.Context, ID string, optionName string, fileName string, file io.ReadCloser) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.JobInputFileUpload")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.JobInputFileUploadPreparer(ctx, ID, optionName, fileName, file)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobInputFileUpload", nil , "Failure preparing request")
        return
        }

                resp, err := client.JobInputFileUploadSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobInputFileUpload", resp, "Failure sending request")
                return
                }

                result, err = client.JobInputFileUploadResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobInputFileUpload", resp, "Failure responding to request")
                }

        return
        }

        // JobInputFileUploadPreparer prepares the JobInputFileUpload request.
        func (client BaseClient) JobInputFileUploadPreparer(ctx context.Context, ID string, optionName string, fileName string, file io.ReadCloser) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

                        queryParameters := map[string]interface{} {
            "fileName": autorest.Encode("query",fileName),
            "optionName": autorest.Encode("query",optionName),
            }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("octet/stream"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/job/{id}/input/file",pathParameters),
        autorest.WithFile(file),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // JobInputFileUploadSender sends the JobInputFileUpload request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) JobInputFileUploadSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // JobInputFileUploadResponder handles the response to the JobInputFileUpload request. The method always
    // closes the http.Response Body.
    func (client BaseClient) JobInputFileUploadResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // JobInputFileUpload1 sends the job input file upload 1 request.
    func (client BaseClient) JobInputFileUpload1(ctx context.Context, ID string) (result JobInputFileListResponse, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.JobInputFileUpload1")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.JobInputFileUpload1Preparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobInputFileUpload1", nil , "Failure preparing request")
        return
        }

                resp, err := client.JobInputFileUpload1Sender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobInputFileUpload1", resp, "Failure sending request")
                return
                }

                result, err = client.JobInputFileUpload1Responder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobInputFileUpload1", resp, "Failure responding to request")
                }

        return
        }

        // JobInputFileUpload1Preparer prepares the JobInputFileUpload1 request.
        func (client BaseClient) JobInputFileUpload1Preparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/job/{id}/input/files",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // JobInputFileUpload1Sender sends the JobInputFileUpload1 request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) JobInputFileUpload1Sender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // JobInputFileUpload1Responder handles the response to the JobInputFileUpload1 request. The method always
    // closes the http.Response Body.
    func (client BaseClient) JobInputFileUpload1Responder(resp *http.Response) (result JobInputFileListResponse, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // JobList sends the job list request.
        // Parameters:
            // project - project name
            // IDList - comma separated list of Job IDs to include
            // groupPath - group or partial group path to include all jobs within that group path. Set to the special value
            // "-" to match the top level jobs only.
            // jobFilter - a filter for the job name. Matches any job name that contains this value.
            // jobExactFilter - an exact job name to match.
            // groupPathExact - an exact group path to match. Set to the special value "-" to match the top level jobs
            // only.
            // scheduledFilter - specify whether to return only scheduled or only not scheduled jobs.
            // serverNodeUUIDFilter - in cluster mode, use to select scheduled jobs assigned to the server with the given
            // UUID.
    func (client BaseClient) JobList(ctx context.Context, project string, IDList string, groupPath string, jobFilter string, jobExactFilter string, groupPathExact string, scheduledFilter *bool, serverNodeUUIDFilter string) (result ListJob, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.JobList")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.JobListPreparer(ctx, project, IDList, groupPath, jobFilter, jobExactFilter, groupPathExact, scheduledFilter, serverNodeUUIDFilter)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobList", nil , "Failure preparing request")
        return
        }

                resp, err := client.JobListSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobList", resp, "Failure sending request")
                return
                }

                result, err = client.JobListResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobList", resp, "Failure responding to request")
                }

        return
        }

        // JobListPreparer prepares the JobList request.
        func (client BaseClient) JobListPreparer(ctx context.Context, project string, IDList string, groupPath string, jobFilter string, jobExactFilter string, groupPathExact string, scheduledFilter *bool, serverNodeUUIDFilter string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "project": autorest.Encode("path",project),
                }

                        queryParameters := map[string]interface{} {
            }
                if len(IDList) > 0 {
                queryParameters["idList"] = autorest.Encode("query",IDList)
                }
                if len(groupPath) > 0 {
                queryParameters["groupPath"] = autorest.Encode("query",groupPath)
                    } else {
                    queryParameters["groupPath"] = autorest.Encode("query","*")
                }
                if len(jobFilter) > 0 {
                queryParameters["jobFilter"] = autorest.Encode("query",jobFilter)
                }
                if len(jobExactFilter) > 0 {
                queryParameters["jobExactFilter"] = autorest.Encode("query",jobExactFilter)
                }
                if len(groupPathExact) > 0 {
                queryParameters["groupPathExact"] = autorest.Encode("query",groupPathExact)
                }
                if scheduledFilter != nil {
                queryParameters["scheduledFilter"] = autorest.Encode("query",*scheduledFilter)
                }
                if len(serverNodeUUIDFilter) > 0 {
                queryParameters["serverNodeUUIDFilter"] = autorest.Encode("query",serverNodeUUIDFilter)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/project/{project}/jobs",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // JobListSender sends the JobList request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) JobListSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // JobListResponder handles the response to the JobList request. The method always
    // closes the http.Response Body.
    func (client BaseClient) JobListResponder(resp *http.Response) (result ListJob, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // JobRetryExecution sends the job retry execution request.
    func (client BaseClient) JobRetryExecution(ctx context.Context, jobID string, executionID int32, request *RetryExecutionRequest) (result ExecutionList, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.JobRetryExecution")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.JobRetryExecutionPreparer(ctx, jobID, executionID, request)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobRetryExecution", nil , "Failure preparing request")
        return
        }

                resp, err := client.JobRetryExecutionSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobRetryExecution", resp, "Failure sending request")
                return
                }

                result, err = client.JobRetryExecutionResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobRetryExecution", resp, "Failure responding to request")
                }

        return
        }

        // JobRetryExecutionPreparer prepares the JobRetryExecution request.
        func (client BaseClient) JobRetryExecutionPreparer(ctx context.Context, jobID string, executionID int32, request *RetryExecutionRequest) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "executionID": autorest.Encode("path",executionID),
                "jobID": autorest.Encode("path",jobID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/job/{jobID}/retry/{executionID}",pathParameters))
                if request != nil {
                preparer = autorest.DecoratePreparer(preparer,
                autorest.WithJSON(request))
                }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // JobRetryExecutionSender sends the JobRetryExecution request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) JobRetryExecutionSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // JobRetryExecutionResponder handles the response to the JobRetryExecution request. The method always
    // closes the http.Response Body.
    func (client BaseClient) JobRetryExecutionResponder(resp *http.Response) (result ExecutionList, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // JobScheduleBulkDisable sends the job schedule bulk disable request.
    func (client BaseClient) JobScheduleBulkDisable(ctx context.Context, jobScheduleBulkDisableRequest JobScheduleBulkDisableRequest) (result JobBulkOperationResponse, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.JobScheduleBulkDisable")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: jobScheduleBulkDisableRequest,
                 Constraints: []validation.Constraint{	{Target: "jobScheduleBulkDisableRequest.Ids", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
                return result, validation.NewError("rundeck.BaseClient", "JobScheduleBulkDisable", err.Error())
                }

                    req, err := client.JobScheduleBulkDisablePreparer(ctx, jobScheduleBulkDisableRequest)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobScheduleBulkDisable", nil , "Failure preparing request")
        return
        }

                resp, err := client.JobScheduleBulkDisableSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobScheduleBulkDisable", resp, "Failure sending request")
                return
                }

                result, err = client.JobScheduleBulkDisableResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobScheduleBulkDisable", resp, "Failure responding to request")
                }

        return
        }

        // JobScheduleBulkDisablePreparer prepares the JobScheduleBulkDisable request.
        func (client BaseClient) JobScheduleBulkDisablePreparer(ctx context.Context, jobScheduleBulkDisableRequest JobScheduleBulkDisableRequest) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/jobs/schedule/disable"),
        autorest.WithJSON(jobScheduleBulkDisableRequest))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // JobScheduleBulkDisableSender sends the JobScheduleBulkDisable request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) JobScheduleBulkDisableSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // JobScheduleBulkDisableResponder handles the response to the JobScheduleBulkDisable request. The method always
    // closes the http.Response Body.
    func (client BaseClient) JobScheduleBulkDisableResponder(resp *http.Response) (result JobBulkOperationResponse, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // JobScheduleBulkEnable sends the job schedule bulk enable request.
    func (client BaseClient) JobScheduleBulkEnable(ctx context.Context, jobScheduleBulkEnableRequest JobScheduleBulkEnableRequest) (result JobBulkOperationResponse, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.JobScheduleBulkEnable")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: jobScheduleBulkEnableRequest,
                 Constraints: []validation.Constraint{	{Target: "jobScheduleBulkEnableRequest.Ids", Name: validation.Null, Rule: true, Chain: nil }}}}); err != nil {
                return result, validation.NewError("rundeck.BaseClient", "JobScheduleBulkEnable", err.Error())
                }

                    req, err := client.JobScheduleBulkEnablePreparer(ctx, jobScheduleBulkEnableRequest)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobScheduleBulkEnable", nil , "Failure preparing request")
        return
        }

                resp, err := client.JobScheduleBulkEnableSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobScheduleBulkEnable", resp, "Failure sending request")
                return
                }

                result, err = client.JobScheduleBulkEnableResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobScheduleBulkEnable", resp, "Failure responding to request")
                }

        return
        }

        // JobScheduleBulkEnablePreparer prepares the JobScheduleBulkEnable request.
        func (client BaseClient) JobScheduleBulkEnablePreparer(ctx context.Context, jobScheduleBulkEnableRequest JobScheduleBulkEnableRequest) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/jobs/schedule/enable"),
        autorest.WithJSON(jobScheduleBulkEnableRequest))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // JobScheduleBulkEnableSender sends the JobScheduleBulkEnable request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) JobScheduleBulkEnableSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // JobScheduleBulkEnableResponder handles the response to the JobScheduleBulkEnable request. The method always
    // closes the http.Response Body.
    func (client BaseClient) JobScheduleBulkEnableResponder(resp *http.Response) (result JobBulkOperationResponse, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // JobScheduleDisable sends the job schedule disable request.
    func (client BaseClient) JobScheduleDisable(ctx context.Context, ID string) (result JobScheduleDisableOKResponse, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.JobScheduleDisable")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.JobScheduleDisablePreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobScheduleDisable", nil , "Failure preparing request")
        return
        }

                resp, err := client.JobScheduleDisableSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobScheduleDisable", resp, "Failure sending request")
                return
                }

                result, err = client.JobScheduleDisableResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobScheduleDisable", resp, "Failure responding to request")
                }

        return
        }

        // JobScheduleDisablePreparer prepares the JobScheduleDisable request.
        func (client BaseClient) JobScheduleDisablePreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/job/{id}/schedule/disable",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // JobScheduleDisableSender sends the JobScheduleDisable request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) JobScheduleDisableSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // JobScheduleDisableResponder handles the response to the JobScheduleDisable request. The method always
    // closes the http.Response Body.
    func (client BaseClient) JobScheduleDisableResponder(resp *http.Response) (result JobScheduleDisableOKResponse, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // JobScheduleEnable sends the job schedule enable request.
    func (client BaseClient) JobScheduleEnable(ctx context.Context, ID string) (result JobScheduleEnableOKResponse, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.JobScheduleEnable")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.JobScheduleEnablePreparer(ctx, ID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobScheduleEnable", nil , "Failure preparing request")
        return
        }

                resp, err := client.JobScheduleEnableSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobScheduleEnable", resp, "Failure sending request")
                return
                }

                result, err = client.JobScheduleEnableResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "JobScheduleEnable", resp, "Failure responding to request")
                }

        return
        }

        // JobScheduleEnablePreparer prepares the JobScheduleEnable request.
        func (client BaseClient) JobScheduleEnablePreparer(ctx context.Context, ID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "id": autorest.Encode("path",ID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/job/{id}/schedule/enable",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // JobScheduleEnableSender sends the JobScheduleEnable request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) JobScheduleEnableSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // JobScheduleEnableResponder handles the response to the JobScheduleEnable request. The method always
    // closes the http.Response Body.
    func (client BaseClient) JobScheduleEnableResponder(resp *http.Response) (result JobScheduleEnableOKResponse, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // MetricList sends the metric list request.
    func (client BaseClient) MetricList(ctx context.Context) (result MetricListOKResponse, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.MetricList")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.MetricListPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "MetricList", nil , "Failure preparing request")
        return
        }

                resp, err := client.MetricListSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "MetricList", resp, "Failure sending request")
                return
                }

                result, err = client.MetricListResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "MetricList", resp, "Failure responding to request")
                }

        return
        }

        // MetricListPreparer prepares the MetricList request.
        func (client BaseClient) MetricListPreparer(ctx context.Context) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/metrics"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // MetricListSender sends the MetricList request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) MetricListSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // MetricListResponder handles the response to the MetricList request. The method always
    // closes the http.Response Body.
    func (client BaseClient) MetricListResponder(resp *http.Response) (result MetricListOKResponse, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // ProjectArchiveExportSync sends the project archive export sync request.
        // Parameters:
            // project - name of the project to import jobs into.
            // executionIds - a list (comma-separated) of execution IDs. If this is specified then the archive will contain
            // only executions that are specified, and will not contain Jobs, ACLs, or project configuration/readme files.
            // exportAll - export all project resources
            // exportJobs - export all project resources
            // exportExecutions - export all project resources
            // exportConfigs - export all project resources
            // exportReadmes - export all project resources
            // exportAcls - export all project resources
    func (client BaseClient) ProjectArchiveExportSync(ctx context.Context, project string, executionIds *bool, exportAll *bool, exportJobs *bool, exportExecutions *bool, exportConfigs *bool, exportReadmes *bool, exportAcls *bool) (result ReadCloser, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ProjectArchiveExportSync")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ProjectArchiveExportSyncPreparer(ctx, project, executionIds, exportAll, exportJobs, exportExecutions, exportConfigs, exportReadmes, exportAcls)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectArchiveExportSync", nil , "Failure preparing request")
        return
        }

                resp, err := client.ProjectArchiveExportSyncSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectArchiveExportSync", resp, "Failure sending request")
                return
                }

                result, err = client.ProjectArchiveExportSyncResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectArchiveExportSync", resp, "Failure responding to request")
                }

        return
        }

        // ProjectArchiveExportSyncPreparer prepares the ProjectArchiveExportSync request.
        func (client BaseClient) ProjectArchiveExportSyncPreparer(ctx context.Context, project string, executionIds *bool, exportAll *bool, exportJobs *bool, exportExecutions *bool, exportConfigs *bool, exportReadmes *bool, exportAcls *bool) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "project": autorest.Encode("path",project),
                }

                        queryParameters := map[string]interface{} {
            }
                if executionIds != nil {
                queryParameters["executionIds"] = autorest.Encode("query",*executionIds)
                }
                if exportAll != nil {
                queryParameters["exportAll"] = autorest.Encode("query",*exportAll)
                    } else {
                    queryParameters["exportAll"] = autorest.Encode("query",true)
                }
                if exportJobs != nil {
                queryParameters["exportJobs"] = autorest.Encode("query",*exportJobs)
                }
                if exportExecutions != nil {
                queryParameters["exportExecutions"] = autorest.Encode("query",*exportExecutions)
                }
                if exportConfigs != nil {
                queryParameters["exportConfigs"] = autorest.Encode("query",*exportConfigs)
                }
                if exportReadmes != nil {
                queryParameters["exportReadmes"] = autorest.Encode("query",*exportReadmes)
                }
                if exportAcls != nil {
                queryParameters["exportAcls"] = autorest.Encode("query",*exportAcls)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/project/{project}/export",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ProjectArchiveExportSyncSender sends the ProjectArchiveExportSync request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ProjectArchiveExportSyncSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ProjectArchiveExportSyncResponder handles the response to the ProjectArchiveExportSync request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ProjectArchiveExportSyncResponder(resp *http.Response) (result ReadCloser, err error) {
        result.Value = &resp.Body
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK))
        result.Response = autorest.Response{Response: resp}
            return
        }

    // ProjectArchiveImport sends the project archive import request.
        // Parameters:
            // project - name of the project to import jobs into.
            // jobUUIDOption -
    func (client BaseClient) ProjectArchiveImport(ctx context.Context, project string, file io.ReadCloser, jobUUIDOption string, importExecutions *bool, importConfig *bool, importACL *bool) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ProjectArchiveImport")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ProjectArchiveImportPreparer(ctx, project, file, jobUUIDOption, importExecutions, importConfig, importACL)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectArchiveImport", nil , "Failure preparing request")
        return
        }

                resp, err := client.ProjectArchiveImportSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectArchiveImport", resp, "Failure sending request")
                return
                }

                result, err = client.ProjectArchiveImportResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectArchiveImport", resp, "Failure responding to request")
                }

        return
        }

        // ProjectArchiveImportPreparer prepares the ProjectArchiveImport request.
        func (client BaseClient) ProjectArchiveImportPreparer(ctx context.Context, project string, file io.ReadCloser, jobUUIDOption string, importExecutions *bool, importConfig *bool, importACL *bool) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "project": autorest.Encode("path",project),
                }

                        queryParameters := map[string]interface{} {
            }
                if len(string(jobUUIDOption)) > 0 {
                queryParameters["jobUuidOption"] = autorest.Encode("query",jobUUIDOption)
                    } else {
                    queryParameters["jobUuidOption"] = autorest.Encode("query","remove")
                }
                if importExecutions != nil {
                queryParameters["importExecutions"] = autorest.Encode("query",*importExecutions)
                }
                if importConfig != nil {
                queryParameters["importConfig"] = autorest.Encode("query",*importConfig)
                }
                if importACL != nil {
                queryParameters["importACL"] = autorest.Encode("query",*importACL)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/zip"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/project/{project}/import",pathParameters),
        autorest.WithFile(file),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ProjectArchiveImportSender sends the ProjectArchiveImport request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ProjectArchiveImportSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ProjectArchiveImportResponder handles the response to the ProjectArchiveImport request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ProjectArchiveImportResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // ProjectConfigGet sends the project config get request.
    func (client BaseClient) ProjectConfigGet(ctx context.Context, project string) (result SetObject, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ProjectConfigGet")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ProjectConfigGetPreparer(ctx, project)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectConfigGet", nil , "Failure preparing request")
        return
        }

                resp, err := client.ProjectConfigGetSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectConfigGet", resp, "Failure sending request")
                return
                }

                result, err = client.ProjectConfigGetResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectConfigGet", resp, "Failure responding to request")
                }

        return
        }

        // ProjectConfigGetPreparer prepares the ProjectConfigGet request.
        func (client BaseClient) ProjectConfigGetPreparer(ctx context.Context, project string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "project": autorest.Encode("path",project),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/project/{project}/config",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ProjectConfigGetSender sends the ProjectConfigGet request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ProjectConfigGetSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ProjectConfigGetResponder handles the response to the ProjectConfigGet request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ProjectConfigGetResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // ProjectConfigKeyDelete sends the project config key delete request.
    func (client BaseClient) ProjectConfigKeyDelete(ctx context.Context, project string, key string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ProjectConfigKeyDelete")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ProjectConfigKeyDeletePreparer(ctx, project, key)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectConfigKeyDelete", nil , "Failure preparing request")
        return
        }

                resp, err := client.ProjectConfigKeyDeleteSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectConfigKeyDelete", resp, "Failure sending request")
                return
                }

                result, err = client.ProjectConfigKeyDeleteResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectConfigKeyDelete", resp, "Failure responding to request")
                }

        return
        }

        // ProjectConfigKeyDeletePreparer prepares the ProjectConfigKeyDelete request.
        func (client BaseClient) ProjectConfigKeyDeletePreparer(ctx context.Context, project string, key string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "key": autorest.Encode("path",key),
                "project": autorest.Encode("path",project),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/project/{project}/config/{key}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ProjectConfigKeyDeleteSender sends the ProjectConfigKeyDelete request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ProjectConfigKeyDeleteSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ProjectConfigKeyDeleteResponder handles the response to the ProjectConfigKeyDelete request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ProjectConfigKeyDeleteResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // ProjectConfigKeyGet sends the project config key get request.
    func (client BaseClient) ProjectConfigKeyGet(ctx context.Context, project string, key string) (result ProjectConfigKeyGetOKResponse, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ProjectConfigKeyGet")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ProjectConfigKeyGetPreparer(ctx, project, key)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectConfigKeyGet", nil , "Failure preparing request")
        return
        }

                resp, err := client.ProjectConfigKeyGetSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectConfigKeyGet", resp, "Failure sending request")
                return
                }

                result, err = client.ProjectConfigKeyGetResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectConfigKeyGet", resp, "Failure responding to request")
                }

        return
        }

        // ProjectConfigKeyGetPreparer prepares the ProjectConfigKeyGet request.
        func (client BaseClient) ProjectConfigKeyGetPreparer(ctx context.Context, project string, key string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "key": autorest.Encode("path",key),
                "project": autorest.Encode("path",project),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/project/{project}/config/{key}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ProjectConfigKeyGetSender sends the ProjectConfigKeyGet request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ProjectConfigKeyGetSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ProjectConfigKeyGetResponder handles the response to the ProjectConfigKeyGet request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ProjectConfigKeyGetResponder(resp *http.Response) (result ProjectConfigKeyGetOKResponse, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // ProjectConfigKeySet sends the project config key set request.
    func (client BaseClient) ProjectConfigKeySet(ctx context.Context, project string, key string, projectConfigKeySetRequest ProjectConfigKeySetRequest) (result ProjectConfigKeySetOKResponse, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ProjectConfigKeySet")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ProjectConfigKeySetPreparer(ctx, project, key, projectConfigKeySetRequest)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectConfigKeySet", nil , "Failure preparing request")
        return
        }

                resp, err := client.ProjectConfigKeySetSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectConfigKeySet", resp, "Failure sending request")
                return
                }

                result, err = client.ProjectConfigKeySetResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectConfigKeySet", resp, "Failure responding to request")
                }

        return
        }

        // ProjectConfigKeySetPreparer prepares the ProjectConfigKeySet request.
        func (client BaseClient) ProjectConfigKeySetPreparer(ctx context.Context, project string, key string, projectConfigKeySetRequest ProjectConfigKeySetRequest) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "key": autorest.Encode("path",key),
                "project": autorest.Encode("path",project),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/project/{project}/config/{key}",pathParameters),
        autorest.WithJSON(projectConfigKeySetRequest))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ProjectConfigKeySetSender sends the ProjectConfigKeySet request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ProjectConfigKeySetSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ProjectConfigKeySetResponder handles the response to the ProjectConfigKeySet request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ProjectConfigKeySetResponder(resp *http.Response) (result ProjectConfigKeySetOKResponse, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // ProjectConfigUpdate sends the project config update request.
    func (client BaseClient) ProjectConfigUpdate(ctx context.Context, project string, projectConfigUpdateRequest interface{}) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ProjectConfigUpdate")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ProjectConfigUpdatePreparer(ctx, project, projectConfigUpdateRequest)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectConfigUpdate", nil , "Failure preparing request")
        return
        }

                resp, err := client.ProjectConfigUpdateSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectConfigUpdate", resp, "Failure sending request")
                return
                }

                result, err = client.ProjectConfigUpdateResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectConfigUpdate", resp, "Failure responding to request")
                }

        return
        }

        // ProjectConfigUpdatePreparer prepares the ProjectConfigUpdate request.
        func (client BaseClient) ProjectConfigUpdatePreparer(ctx context.Context, project string, projectConfigUpdateRequest interface{}) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "project": autorest.Encode("path",project),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/project/{project}/config",pathParameters),
        autorest.WithJSON(projectConfigUpdateRequest))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ProjectConfigUpdateSender sends the ProjectConfigUpdate request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ProjectConfigUpdateSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ProjectConfigUpdateResponder handles the response to the ProjectConfigUpdate request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ProjectConfigUpdateResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // ProjectCreate sends the project create request.
    func (client BaseClient) ProjectCreate(ctx context.Context, projectCreateRequest ProjectCreateRequest) (result SetObject, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ProjectCreate")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ProjectCreatePreparer(ctx, projectCreateRequest)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectCreate", nil , "Failure preparing request")
        return
        }

                resp, err := client.ProjectCreateSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectCreate", resp, "Failure sending request")
                return
                }

                result, err = client.ProjectCreateResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectCreate", resp, "Failure responding to request")
                }

        return
        }

        // ProjectCreatePreparer prepares the ProjectCreate request.
        func (client BaseClient) ProjectCreatePreparer(ctx context.Context, projectCreateRequest ProjectCreateRequest) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/projects"),
        autorest.WithJSON(projectCreateRequest))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ProjectCreateSender sends the ProjectCreate request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ProjectCreateSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ProjectCreateResponder handles the response to the ProjectCreate request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ProjectCreateResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusCreated),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // ProjectDelete sends the project delete request.
    func (client BaseClient) ProjectDelete(ctx context.Context, project string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ProjectDelete")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ProjectDeletePreparer(ctx, project)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectDelete", nil , "Failure preparing request")
        return
        }

                resp, err := client.ProjectDeleteSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectDelete", resp, "Failure sending request")
                return
                }

                result, err = client.ProjectDeleteResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectDelete", resp, "Failure responding to request")
                }

        return
        }

        // ProjectDeletePreparer prepares the ProjectDelete request.
        func (client BaseClient) ProjectDeletePreparer(ctx context.Context, project string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "project": autorest.Encode("path",project),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/project/{project}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ProjectDeleteSender sends the ProjectDelete request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ProjectDeleteSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ProjectDeleteResponder handles the response to the ProjectDelete request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ProjectDeleteResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // ProjectGet sends the project get request.
    func (client BaseClient) ProjectGet(ctx context.Context, project string) (result Project, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ProjectGet")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ProjectGetPreparer(ctx, project)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectGet", nil , "Failure preparing request")
        return
        }

                resp, err := client.ProjectGetSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectGet", resp, "Failure sending request")
                return
                }

                result, err = client.ProjectGetResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectGet", resp, "Failure responding to request")
                }

        return
        }

        // ProjectGetPreparer prepares the ProjectGet request.
        func (client BaseClient) ProjectGetPreparer(ctx context.Context, project string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "project": autorest.Encode("path",project),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/project/{project}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ProjectGetSender sends the ProjectGet request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ProjectGetSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ProjectGetResponder handles the response to the ProjectGet request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ProjectGetResponder(resp *http.Response) (result Project, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // ProjectJobsExport sends the project jobs export request.
        // Parameters:
            // project - the project to export jobs for.
            // formatParameter - XML or YAML format for exported jobs.
            // idlist - a comma-separated list of Job IDs to export.
            // groupPath - group or partial group path to include all jobs within that group path.
            // jobFilter - filter for the job Name.
    func (client BaseClient) ProjectJobsExport(ctx context.Context, project string, formatParameter string, idlist string, groupPath string, jobFilter string) (result String, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ProjectJobsExport")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ProjectJobsExportPreparer(ctx, project, formatParameter, idlist, groupPath, jobFilter)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectJobsExport", nil , "Failure preparing request")
        return
        }

                resp, err := client.ProjectJobsExportSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectJobsExport", resp, "Failure sending request")
                return
                }

                result, err = client.ProjectJobsExportResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectJobsExport", resp, "Failure responding to request")
                }

        return
        }

        // ProjectJobsExportPreparer prepares the ProjectJobsExport request.
        func (client BaseClient) ProjectJobsExportPreparer(ctx context.Context, project string, formatParameter string, idlist string, groupPath string, jobFilter string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "project": autorest.Encode("path",project),
                }

                        queryParameters := map[string]interface{} {
            }
                if len(string(formatParameter)) > 0 {
                queryParameters["format"] = autorest.Encode("query",formatParameter)
                    } else {
                    queryParameters["format"] = autorest.Encode("query","xml")
                }
                if len(idlist) > 0 {
                queryParameters["idlist"] = autorest.Encode("query",idlist)
                }
                if len(groupPath) > 0 {
                queryParameters["groupPath"] = autorest.Encode("query",groupPath)
                }
                if len(jobFilter) > 0 {
                queryParameters["jobFilter"] = autorest.Encode("query",jobFilter)
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/project/{project}/jobs/export",pathParameters),
        autorest.WithQueryParameters(queryParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ProjectJobsExportSender sends the ProjectJobsExport request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ProjectJobsExportSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ProjectJobsExportResponder handles the response to the ProjectJobsExport request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ProjectJobsExportResponder(resp *http.Response) (result String, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // ProjectJobsImport sends the project jobs import request.
        // Parameters:
            // project - name of the project to import jobs into.
    func (client BaseClient) ProjectJobsImport(ctx context.Context, project string, file io.ReadCloser, contentType string, accept string, fileFormat string, dupeOption string, UUIDOption string) (result ReadCloser, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ProjectJobsImport")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ProjectJobsImportPreparer(ctx, project, file, contentType, accept, fileFormat, dupeOption, UUIDOption)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectJobsImport", nil , "Failure preparing request")
        return
        }

                resp, err := client.ProjectJobsImportSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectJobsImport", resp, "Failure sending request")
                return
                }

                result, err = client.ProjectJobsImportResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectJobsImport", resp, "Failure responding to request")
                }

        return
        }

        // ProjectJobsImportPreparer prepares the ProjectJobsImport request.
        func (client BaseClient) ProjectJobsImportPreparer(ctx context.Context, project string, file io.ReadCloser, contentType string, accept string, fileFormat string, dupeOption string, UUIDOption string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "project": autorest.Encode("path",project),
                }

                        queryParameters := map[string]interface{} {
            }
                if len(fileFormat) > 0 {
                queryParameters["fileFormat"] = autorest.Encode("query",fileFormat)
                    } else {
                    queryParameters["fileFormat"] = autorest.Encode("query","xml")
                }
                if len(dupeOption) > 0 {
                queryParameters["dupeOption"] = autorest.Encode("query",dupeOption)
                    } else {
                    queryParameters["dupeOption"] = autorest.Encode("query","create")
                }
                if len(UUIDOption) > 0 {
                queryParameters["uuidOption"] = autorest.Encode("query",UUIDOption)
                    } else {
                    queryParameters["uuidOption"] = autorest.Encode("query","preserve")
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/project/{project}/jobs/import",pathParameters),
        autorest.WithFile(file),
        autorest.WithQueryParameters(queryParameters))
                if len(contentType) > 0 {
                preparer = autorest.DecoratePreparer(preparer,
                autorest.WithHeader("content-type",autorest.String(contentType)))
                     } else {
                    preparer = autorest.DecoratePreparer(preparer,
                    autorest.WithHeader("content-type",autorest.String("application/xml")))
                }
                if len(accept) > 0 {
                preparer = autorest.DecoratePreparer(preparer,
                autorest.WithHeader("accept",autorest.String(accept)))
                     } else {
                    preparer = autorest.DecoratePreparer(preparer,
                    autorest.WithHeader("accept",autorest.String("application/xml")))
                }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ProjectJobsImportSender sends the ProjectJobsImport request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ProjectJobsImportSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ProjectJobsImportResponder handles the response to the ProjectJobsImport request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ProjectJobsImportResponder(resp *http.Response) (result ReadCloser, err error) {
        result.Value = &resp.Body
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK))
        result.Response = autorest.Response{Response: resp}
            return
        }

    // ProjectList sends the project list request.
    func (client BaseClient) ProjectList(ctx context.Context) (result ListProjectListOKResponseItem, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ProjectList")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ProjectListPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectList", nil , "Failure preparing request")
        return
        }

                resp, err := client.ProjectListSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectList", resp, "Failure sending request")
                return
                }

                result, err = client.ProjectListResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectList", resp, "Failure responding to request")
                }

        return
        }

        // ProjectListPreparer prepares the ProjectList request.
        func (client BaseClient) ProjectListPreparer(ctx context.Context) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/projects"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ProjectListSender sends the ProjectList request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ProjectListSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ProjectListResponder handles the response to the ProjectList request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ProjectListResponder(resp *http.Response) (result ListProjectListOKResponseItem, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // ProjectMotdDelete sends the project motd delete request.
        // Parameters:
            // project - name of the project to import jobs into.
    func (client BaseClient) ProjectMotdDelete(ctx context.Context, project string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ProjectMotdDelete")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ProjectMotdDeletePreparer(ctx, project)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectMotdDelete", nil , "Failure preparing request")
        return
        }

                resp, err := client.ProjectMotdDeleteSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectMotdDelete", resp, "Failure sending request")
                return
                }

                result, err = client.ProjectMotdDeleteResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectMotdDelete", resp, "Failure responding to request")
                }

        return
        }

        // ProjectMotdDeletePreparer prepares the ProjectMotdDelete request.
        func (client BaseClient) ProjectMotdDeletePreparer(ctx context.Context, project string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "project": autorest.Encode("path",project),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/project/{project}/motd.md",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ProjectMotdDeleteSender sends the ProjectMotdDelete request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ProjectMotdDeleteSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ProjectMotdDeleteResponder handles the response to the ProjectMotdDelete request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ProjectMotdDeleteResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // ProjectMotdGet sends the project motd get request.
        // Parameters:
            // project - name of the project to import jobs into.
    func (client BaseClient) ProjectMotdGet(ctx context.Context, project string) (result ProjectMotdGetOKResponse, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ProjectMotdGet")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ProjectMotdGetPreparer(ctx, project)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectMotdGet", nil , "Failure preparing request")
        return
        }

                resp, err := client.ProjectMotdGetSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectMotdGet", resp, "Failure sending request")
                return
                }

                result, err = client.ProjectMotdGetResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectMotdGet", resp, "Failure responding to request")
                }

        return
        }

        // ProjectMotdGetPreparer prepares the ProjectMotdGet request.
        func (client BaseClient) ProjectMotdGetPreparer(ctx context.Context, project string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "project": autorest.Encode("path",project),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/project/{project}/motd.md",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ProjectMotdGetSender sends the ProjectMotdGet request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ProjectMotdGetSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ProjectMotdGetResponder handles the response to the ProjectMotdGet request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ProjectMotdGetResponder(resp *http.Response) (result ProjectMotdGetOKResponse, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // ProjectMotdPut sends the project motd put request.
        // Parameters:
            // project - name of the project to import jobs into.
    func (client BaseClient) ProjectMotdPut(ctx context.Context, project string, motdUpdateRequest MotdUpdateRequest) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ProjectMotdPut")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ProjectMotdPutPreparer(ctx, project, motdUpdateRequest)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectMotdPut", nil , "Failure preparing request")
        return
        }

                resp, err := client.ProjectMotdPutSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectMotdPut", resp, "Failure sending request")
                return
                }

                result, err = client.ProjectMotdPutResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectMotdPut", resp, "Failure responding to request")
                }

        return
        }

        // ProjectMotdPutPreparer prepares the ProjectMotdPut request.
        func (client BaseClient) ProjectMotdPutPreparer(ctx context.Context, project string, motdUpdateRequest MotdUpdateRequest) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "project": autorest.Encode("path",project),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/project/{project}/motd.md",pathParameters),
        autorest.WithJSON(motdUpdateRequest))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ProjectMotdPutSender sends the ProjectMotdPut request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ProjectMotdPutSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ProjectMotdPutResponder handles the response to the ProjectMotdPut request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ProjectMotdPutResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // ProjectReadmeDelete sends the project readme delete request.
        // Parameters:
            // project - name of the project to import jobs into.
    func (client BaseClient) ProjectReadmeDelete(ctx context.Context, project string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ProjectReadmeDelete")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ProjectReadmeDeletePreparer(ctx, project)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectReadmeDelete", nil , "Failure preparing request")
        return
        }

                resp, err := client.ProjectReadmeDeleteSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectReadmeDelete", resp, "Failure sending request")
                return
                }

                result, err = client.ProjectReadmeDeleteResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectReadmeDelete", resp, "Failure responding to request")
                }

        return
        }

        // ProjectReadmeDeletePreparer prepares the ProjectReadmeDelete request.
        func (client BaseClient) ProjectReadmeDeletePreparer(ctx context.Context, project string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "project": autorest.Encode("path",project),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/project/{project}/readme.md",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ProjectReadmeDeleteSender sends the ProjectReadmeDelete request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ProjectReadmeDeleteSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ProjectReadmeDeleteResponder handles the response to the ProjectReadmeDelete request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ProjectReadmeDeleteResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // ProjectReadmeGet sends the project readme get request.
        // Parameters:
            // project - name of the project to import jobs into.
    func (client BaseClient) ProjectReadmeGet(ctx context.Context, project string) (result ProjectReadmeGetOKResponse, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ProjectReadmeGet")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ProjectReadmeGetPreparer(ctx, project)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectReadmeGet", nil , "Failure preparing request")
        return
        }

                resp, err := client.ProjectReadmeGetSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectReadmeGet", resp, "Failure sending request")
                return
                }

                result, err = client.ProjectReadmeGetResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectReadmeGet", resp, "Failure responding to request")
                }

        return
        }

        // ProjectReadmeGetPreparer prepares the ProjectReadmeGet request.
        func (client BaseClient) ProjectReadmeGetPreparer(ctx context.Context, project string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "project": autorest.Encode("path",project),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/project/{project}/readme.md",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ProjectReadmeGetSender sends the ProjectReadmeGet request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ProjectReadmeGetSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ProjectReadmeGetResponder handles the response to the ProjectReadmeGet request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ProjectReadmeGetResponder(resp *http.Response) (result ProjectReadmeGetOKResponse, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // ProjectReadmePut sends the project readme put request.
        // Parameters:
            // project - name of the project to import jobs into.
    func (client BaseClient) ProjectReadmePut(ctx context.Context, project string, readmeUpdateRequest ReadmeUpdateRequest) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.ProjectReadmePut")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.ProjectReadmePutPreparer(ctx, project, readmeUpdateRequest)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectReadmePut", nil , "Failure preparing request")
        return
        }

                resp, err := client.ProjectReadmePutSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectReadmePut", resp, "Failure sending request")
                return
                }

                result, err = client.ProjectReadmePutResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "ProjectReadmePut", resp, "Failure responding to request")
                }

        return
        }

        // ProjectReadmePutPreparer prepares the ProjectReadmePut request.
        func (client BaseClient) ProjectReadmePutPreparer(ctx context.Context, project string, readmeUpdateRequest ReadmeUpdateRequest) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "project": autorest.Encode("path",project),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/project/{project}/readme.md",pathParameters),
        autorest.WithJSON(readmeUpdateRequest))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // ProjectReadmePutSender sends the ProjectReadmePut request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) ProjectReadmePutSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // ProjectReadmePutResponder handles the response to the ProjectReadmePut request. The method always
    // closes the http.Response Body.
    func (client BaseClient) ProjectReadmePutResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // StorageKeyCreate sends the storage key create request.
        // Parameters:
            // pathParameter - key path
    func (client BaseClient) StorageKeyCreate(ctx context.Context, pathParameter string, file io.ReadCloser, contentType string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.StorageKeyCreate")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.StorageKeyCreatePreparer(ctx, pathParameter, file, contentType)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "StorageKeyCreate", nil , "Failure preparing request")
        return
        }

                resp, err := client.StorageKeyCreateSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "StorageKeyCreate", resp, "Failure sending request")
                return
                }

                result, err = client.StorageKeyCreateResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "StorageKeyCreate", resp, "Failure responding to request")
                }

        return
        }

        // StorageKeyCreatePreparer prepares the StorageKeyCreate request.
        func (client BaseClient) StorageKeyCreatePreparer(ctx context.Context, pathParameter string, file io.ReadCloser, contentType string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "path": pathParameter,
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/pgp-keys"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/storage/keys/{path}",pathParameters),
        autorest.WithFile(file))
                if len(contentType) > 0 {
                preparer = autorest.DecoratePreparer(preparer,
                autorest.WithHeader("content-type",autorest.String(contentType)))
                     } else {
                    preparer = autorest.DecoratePreparer(preparer,
                    autorest.WithHeader("content-type",autorest.String("application/pgp-keys")))
                }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // StorageKeyCreateSender sends the StorageKeyCreate request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) StorageKeyCreateSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // StorageKeyCreateResponder handles the response to the StorageKeyCreate request. The method always
    // closes the http.Response Body.
    func (client BaseClient) StorageKeyCreateResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusCreated,http.StatusConflict),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // StorageKeyDelete sends the storage key delete request.
        // Parameters:
            // pathParameter - key path
    func (client BaseClient) StorageKeyDelete(ctx context.Context, pathParameter string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.StorageKeyDelete")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.StorageKeyDeletePreparer(ctx, pathParameter)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "StorageKeyDelete", nil , "Failure preparing request")
        return
        }

                resp, err := client.StorageKeyDeleteSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "StorageKeyDelete", resp, "Failure sending request")
                return
                }

                result, err = client.StorageKeyDeleteResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "StorageKeyDelete", resp, "Failure responding to request")
                }

        return
        }

        // StorageKeyDeletePreparer prepares the StorageKeyDelete request.
        func (client BaseClient) StorageKeyDeletePreparer(ctx context.Context, pathParameter string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "path": pathParameter,
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/storage/keys/{path}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // StorageKeyDeleteSender sends the StorageKeyDelete request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) StorageKeyDeleteSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // StorageKeyDeleteResponder handles the response to the StorageKeyDelete request. The method always
    // closes the http.Response Body.
    func (client BaseClient) StorageKeyDeleteResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // StorageKeyGetMaterial this enpoint is impossible to describe properly in OAPI 2.0 .
    // Depending on resources type and accepts header GET can return a list of key metadata,
    // single metadata, or the key contents.
        // Parameters:
            // keyPath - key path
    func (client BaseClient) StorageKeyGetMaterial(ctx context.Context, keyPath string) (result ReadCloser, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.StorageKeyGetMaterial")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.StorageKeyGetMaterialPreparer(ctx, keyPath)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "StorageKeyGetMaterial", nil , "Failure preparing request")
        return
        }

                resp, err := client.StorageKeyGetMaterialSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "StorageKeyGetMaterial", resp, "Failure sending request")
                return
                }

                result, err = client.StorageKeyGetMaterialResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "StorageKeyGetMaterial", resp, "Failure responding to request")
                }

        return
        }

        // StorageKeyGetMaterialPreparer prepares the StorageKeyGetMaterial request.
        func (client BaseClient) StorageKeyGetMaterialPreparer(ctx context.Context, keyPath string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "keyPath": keyPath,
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/storage/keys/{keyPath}",pathParameters),
        autorest.WithHeader("accept", "*/*"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // StorageKeyGetMaterialSender sends the StorageKeyGetMaterial request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) StorageKeyGetMaterialSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // StorageKeyGetMaterialResponder handles the response to the StorageKeyGetMaterial request. The method always
    // closes the http.Response Body.
    func (client BaseClient) StorageKeyGetMaterialResponder(resp *http.Response) (result ReadCloser, err error) {
        result.Value = &resp.Body
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound))
        result.Response = autorest.Response{Response: resp}
            return
        }

    // StorageKeyGetMetadata this enpoint is impossible to describe properly in OAPI 2.0 .
    // Depending on resources type and accepts header GET can return a list of key metadata,
    // single metadata, or the key contents.
        // Parameters:
            // pathParameter - key path
    func (client BaseClient) StorageKeyGetMetadata(ctx context.Context, pathParameter string) (result StorageKeyListResponse, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.StorageKeyGetMetadata")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.StorageKeyGetMetadataPreparer(ctx, pathParameter)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "StorageKeyGetMetadata", nil , "Failure preparing request")
        return
        }

                resp, err := client.StorageKeyGetMetadataSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "StorageKeyGetMetadata", resp, "Failure sending request")
                return
                }

                result, err = client.StorageKeyGetMetadataResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "StorageKeyGetMetadata", resp, "Failure responding to request")
                }

        return
        }

        // StorageKeyGetMetadataPreparer prepares the StorageKeyGetMetadata request.
        func (client BaseClient) StorageKeyGetMetadataPreparer(ctx context.Context, pathParameter string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "path": pathParameter,
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/storage/keys/{path}",pathParameters),
        autorest.WithHeader("accept", "application/json"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // StorageKeyGetMetadataSender sends the StorageKeyGetMetadata request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) StorageKeyGetMetadataSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // StorageKeyGetMetadataResponder handles the response to the StorageKeyGetMetadata request. The method always
    // closes the http.Response Body.
    func (client BaseClient) StorageKeyGetMetadataResponder(resp *http.Response) (result StorageKeyListResponse, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // StorageKeyUpdate sends the storage key update request.
        // Parameters:
            // pathParameter - key path
    func (client BaseClient) StorageKeyUpdate(ctx context.Context, pathParameter string, file io.ReadCloser, contentType string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.StorageKeyUpdate")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.StorageKeyUpdatePreparer(ctx, pathParameter, file, contentType)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "StorageKeyUpdate", nil , "Failure preparing request")
        return
        }

                resp, err := client.StorageKeyUpdateSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "StorageKeyUpdate", resp, "Failure sending request")
                return
                }

                result, err = client.StorageKeyUpdateResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "StorageKeyUpdate", resp, "Failure responding to request")
                }

        return
        }

        // StorageKeyUpdatePreparer prepares the StorageKeyUpdate request.
        func (client BaseClient) StorageKeyUpdatePreparer(ctx context.Context, pathParameter string, file io.ReadCloser, contentType string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "path": pathParameter,
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/pgp-keys"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/storage/keys/{path}",pathParameters),
        autorest.WithFile(file))
                if len(contentType) > 0 {
                preparer = autorest.DecoratePreparer(preparer,
                autorest.WithHeader("content-type",autorest.String(contentType)))
                     } else {
                    preparer = autorest.DecoratePreparer(preparer,
                    autorest.WithHeader("content-type",autorest.String("application/pgp-keys")))
                }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // StorageKeyUpdateSender sends the StorageKeyUpdate request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) StorageKeyUpdateSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // StorageKeyUpdateResponder handles the response to the StorageKeyUpdate request. The method always
    // closes the http.Response Body.
    func (client BaseClient) StorageKeyUpdateResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // SystemACLPolicyCreate sends the system acl policy create request.
        // Parameters:
            // policyName - policy file name
    func (client BaseClient) SystemACLPolicyCreate(ctx context.Context, policyName string, systemACLPolicyCreateRequest *SystemACLPolicyCreateRequest) (result SetObject, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.SystemACLPolicyCreate")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: systemACLPolicyCreateRequest,
                 Constraints: []validation.Constraint{	{Target: "systemACLPolicyCreateRequest", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "systemACLPolicyCreateRequest.Contents", Name: validation.Null, Rule: true, Chain: nil },
                }}}}}); err != nil {
                return result, validation.NewError("rundeck.BaseClient", "SystemACLPolicyCreate", err.Error())
                }

                    req, err := client.SystemACLPolicyCreatePreparer(ctx, policyName, systemACLPolicyCreateRequest)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemACLPolicyCreate", nil , "Failure preparing request")
        return
        }

                resp, err := client.SystemACLPolicyCreateSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemACLPolicyCreate", resp, "Failure sending request")
                return
                }

                result, err = client.SystemACLPolicyCreateResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemACLPolicyCreate", resp, "Failure responding to request")
                }

        return
        }

        // SystemACLPolicyCreatePreparer prepares the SystemACLPolicyCreate request.
        func (client BaseClient) SystemACLPolicyCreatePreparer(ctx context.Context, policyName string, systemACLPolicyCreateRequest *SystemACLPolicyCreateRequest) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "policyName": autorest.Encode("path",policyName),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/system/acl/{policyName}",pathParameters))
                if systemACLPolicyCreateRequest != nil {
                preparer = autorest.DecoratePreparer(preparer,
                autorest.WithJSON(systemACLPolicyCreateRequest))
                }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // SystemACLPolicyCreateSender sends the SystemACLPolicyCreate request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) SystemACLPolicyCreateSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // SystemACLPolicyCreateResponder handles the response to the SystemACLPolicyCreate request. The method always
    // closes the http.Response Body.
    func (client BaseClient) SystemACLPolicyCreateResponder(resp *http.Response) (result SetObject, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusCreated,http.StatusBadRequest,http.StatusConflict),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // SystemACLPolicyDelete sends the system acl policy delete request.
        // Parameters:
            // policyName - policy file name
    func (client BaseClient) SystemACLPolicyDelete(ctx context.Context, policyName string) (result autorest.Response, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.SystemACLPolicyDelete")
            defer func() {
                sc := -1
                if result.Response != nil {
                    sc = result.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.SystemACLPolicyDeletePreparer(ctx, policyName)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemACLPolicyDelete", nil , "Failure preparing request")
        return
        }

                resp, err := client.SystemACLPolicyDeleteSender(req)
                if err != nil {
                result.Response = resp
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemACLPolicyDelete", resp, "Failure sending request")
                return
                }

                result, err = client.SystemACLPolicyDeleteResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemACLPolicyDelete", resp, "Failure responding to request")
                }

        return
        }

        // SystemACLPolicyDeletePreparer prepares the SystemACLPolicyDelete request.
        func (client BaseClient) SystemACLPolicyDeletePreparer(ctx context.Context, policyName string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "policyName": autorest.Encode("path",policyName),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsDelete(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/system/acl/{policyName}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // SystemACLPolicyDeleteSender sends the SystemACLPolicyDelete request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) SystemACLPolicyDeleteSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // SystemACLPolicyDeleteResponder handles the response to the SystemACLPolicyDelete request. The method always
    // closes the http.Response Body.
    func (client BaseClient) SystemACLPolicyDeleteResponder(resp *http.Response) (result autorest.Response, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNoContent,http.StatusNotFound),
        autorest.ByClosing())
        result.Response = resp
            return
        }

    // SystemACLPolicyGet sends the system acl policy get request.
        // Parameters:
            // policyName - policy file name
    func (client BaseClient) SystemACLPolicyGet(ctx context.Context, policyName string) (result ACLPolicyResponse, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.SystemACLPolicyGet")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.SystemACLPolicyGetPreparer(ctx, policyName)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemACLPolicyGet", nil , "Failure preparing request")
        return
        }

                resp, err := client.SystemACLPolicyGetSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemACLPolicyGet", resp, "Failure sending request")
                return
                }

                result, err = client.SystemACLPolicyGetResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemACLPolicyGet", resp, "Failure responding to request")
                }

        return
        }

        // SystemACLPolicyGetPreparer prepares the SystemACLPolicyGet request.
        func (client BaseClient) SystemACLPolicyGetPreparer(ctx context.Context, policyName string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "policyName": autorest.Encode("path",policyName),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/system/acl/{policyName}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // SystemACLPolicyGetSender sends the SystemACLPolicyGet request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) SystemACLPolicyGetSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // SystemACLPolicyGetResponder handles the response to the SystemACLPolicyGet request. The method always
    // closes the http.Response Body.
    func (client BaseClient) SystemACLPolicyGetResponder(resp *http.Response) (result ACLPolicyResponse, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // SystemACLPolicyList sends the system acl policy list request.
    func (client BaseClient) SystemACLPolicyList(ctx context.Context) (result ACLList, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.SystemACLPolicyList")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.SystemACLPolicyListPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemACLPolicyList", nil , "Failure preparing request")
        return
        }

                resp, err := client.SystemACLPolicyListSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemACLPolicyList", resp, "Failure sending request")
                return
                }

                result, err = client.SystemACLPolicyListResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemACLPolicyList", resp, "Failure responding to request")
                }

        return
        }

        // SystemACLPolicyListPreparer prepares the SystemACLPolicyList request.
        func (client BaseClient) SystemACLPolicyListPreparer(ctx context.Context) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/system/acl/"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // SystemACLPolicyListSender sends the SystemACLPolicyList request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) SystemACLPolicyListSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // SystemACLPolicyListResponder handles the response to the SystemACLPolicyList request. The method always
    // closes the http.Response Body.
    func (client BaseClient) SystemACLPolicyListResponder(resp *http.Response) (result ACLList, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // SystemACLPolicyUpdate sends the system acl policy update request.
        // Parameters:
            // policyName - policy file name
    func (client BaseClient) SystemACLPolicyUpdate(ctx context.Context, policyName string, systemACLPolicyUpdateRequest *SystemACLPolicyUpdateRequest) (result ACLPolicyResponse, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.SystemACLPolicyUpdate")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: systemACLPolicyUpdateRequest,
                 Constraints: []validation.Constraint{	{Target: "systemACLPolicyUpdateRequest", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "systemACLPolicyUpdateRequest.Contents", Name: validation.Null, Rule: true, Chain: nil },
                }}}}}); err != nil {
                return result, validation.NewError("rundeck.BaseClient", "SystemACLPolicyUpdate", err.Error())
                }

                    req, err := client.SystemACLPolicyUpdatePreparer(ctx, policyName, systemACLPolicyUpdateRequest)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemACLPolicyUpdate", nil , "Failure preparing request")
        return
        }

                resp, err := client.SystemACLPolicyUpdateSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemACLPolicyUpdate", resp, "Failure sending request")
                return
                }

                result, err = client.SystemACLPolicyUpdateResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemACLPolicyUpdate", resp, "Failure responding to request")
                }

        return
        }

        // SystemACLPolicyUpdatePreparer prepares the SystemACLPolicyUpdate request.
        func (client BaseClient) SystemACLPolicyUpdatePreparer(ctx context.Context, policyName string, systemACLPolicyUpdateRequest *SystemACLPolicyUpdateRequest) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "policyName": autorest.Encode("path",policyName),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/system/acl/{policyName}",pathParameters))
                if systemACLPolicyUpdateRequest != nil {
                preparer = autorest.DecoratePreparer(preparer,
                autorest.WithJSON(systemACLPolicyUpdateRequest))
                }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // SystemACLPolicyUpdateSender sends the SystemACLPolicyUpdate request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) SystemACLPolicyUpdateSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // SystemACLPolicyUpdateResponder handles the response to the SystemACLPolicyUpdate request. The method always
    // closes the http.Response Body.
    func (client BaseClient) SystemACLPolicyUpdateResponder(resp *http.Response) (result ACLPolicyResponse, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK,http.StatusNotFound),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // SystemExecutionsDisable sends the system executions disable request.
    func (client BaseClient) SystemExecutionsDisable(ctx context.Context) (result SystemExecutionsDisableOKResponse, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.SystemExecutionsDisable")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.SystemExecutionsDisablePreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemExecutionsDisable", nil , "Failure preparing request")
        return
        }

                resp, err := client.SystemExecutionsDisableSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemExecutionsDisable", resp, "Failure sending request")
                return
                }

                result, err = client.SystemExecutionsDisableResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemExecutionsDisable", resp, "Failure responding to request")
                }

        return
        }

        // SystemExecutionsDisablePreparer prepares the SystemExecutionsDisable request.
        func (client BaseClient) SystemExecutionsDisablePreparer(ctx context.Context) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/system/executions/disable"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // SystemExecutionsDisableSender sends the SystemExecutionsDisable request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) SystemExecutionsDisableSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // SystemExecutionsDisableResponder handles the response to the SystemExecutionsDisable request. The method always
    // closes the http.Response Body.
    func (client BaseClient) SystemExecutionsDisableResponder(resp *http.Response) (result SystemExecutionsDisableOKResponse, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // SystemExecutionsEnable sends the system executions enable request.
    func (client BaseClient) SystemExecutionsEnable(ctx context.Context) (result SystemExecutionsEnableOKResponse, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.SystemExecutionsEnable")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.SystemExecutionsEnablePreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemExecutionsEnable", nil , "Failure preparing request")
        return
        }

                resp, err := client.SystemExecutionsEnableSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemExecutionsEnable", resp, "Failure sending request")
                return
                }

                result, err = client.SystemExecutionsEnableResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemExecutionsEnable", resp, "Failure responding to request")
                }

        return
        }

        // SystemExecutionsEnablePreparer prepares the SystemExecutionsEnable request.
        func (client BaseClient) SystemExecutionsEnablePreparer(ctx context.Context) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/system/executions/enable"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // SystemExecutionsEnableSender sends the SystemExecutionsEnable request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) SystemExecutionsEnableSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // SystemExecutionsEnableResponder handles the response to the SystemExecutionsEnable request. The method always
    // closes the http.Response Body.
    func (client BaseClient) SystemExecutionsEnableResponder(resp *http.Response) (result SystemExecutionsEnableOKResponse, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // SystemIncompleteLogStorageExecutionsGet sends the system incomplete log storage executions get request.
    func (client BaseClient) SystemIncompleteLogStorageExecutionsGet(ctx context.Context) (result IncompleteLogExecutions, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.SystemIncompleteLogStorageExecutionsGet")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.SystemIncompleteLogStorageExecutionsGetPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemIncompleteLogStorageExecutionsGet", nil , "Failure preparing request")
        return
        }

                resp, err := client.SystemIncompleteLogStorageExecutionsGetSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemIncompleteLogStorageExecutionsGet", resp, "Failure sending request")
                return
                }

                result, err = client.SystemIncompleteLogStorageExecutionsGetResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemIncompleteLogStorageExecutionsGet", resp, "Failure responding to request")
                }

        return
        }

        // SystemIncompleteLogStorageExecutionsGetPreparer prepares the SystemIncompleteLogStorageExecutionsGet request.
        func (client BaseClient) SystemIncompleteLogStorageExecutionsGetPreparer(ctx context.Context) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/system/logstorage/incomplete"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // SystemIncompleteLogStorageExecutionsGetSender sends the SystemIncompleteLogStorageExecutionsGet request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) SystemIncompleteLogStorageExecutionsGetSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // SystemIncompleteLogStorageExecutionsGetResponder handles the response to the SystemIncompleteLogStorageExecutionsGet request. The method always
    // closes the http.Response Body.
    func (client BaseClient) SystemIncompleteLogStorageExecutionsGetResponder(resp *http.Response) (result IncompleteLogExecutions, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // SystemIncompleteLogStorageExecutionsResume sends the system incomplete log storage executions resume request.
    func (client BaseClient) SystemIncompleteLogStorageExecutionsResume(ctx context.Context) (result SystemIncompleteLogStorageExecutionsResumeOKResponse, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.SystemIncompleteLogStorageExecutionsResume")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.SystemIncompleteLogStorageExecutionsResumePreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemIncompleteLogStorageExecutionsResume", nil , "Failure preparing request")
        return
        }

                resp, err := client.SystemIncompleteLogStorageExecutionsResumeSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemIncompleteLogStorageExecutionsResume", resp, "Failure sending request")
                return
                }

                result, err = client.SystemIncompleteLogStorageExecutionsResumeResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemIncompleteLogStorageExecutionsResume", resp, "Failure responding to request")
                }

        return
        }

        // SystemIncompleteLogStorageExecutionsResumePreparer prepares the SystemIncompleteLogStorageExecutionsResume request.
        func (client BaseClient) SystemIncompleteLogStorageExecutionsResumePreparer(ctx context.Context) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/system/logstorage/incomplete/resume"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // SystemIncompleteLogStorageExecutionsResumeSender sends the SystemIncompleteLogStorageExecutionsResume request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) SystemIncompleteLogStorageExecutionsResumeSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // SystemIncompleteLogStorageExecutionsResumeResponder handles the response to the SystemIncompleteLogStorageExecutionsResume request. The method always
    // closes the http.Response Body.
    func (client BaseClient) SystemIncompleteLogStorageExecutionsResumeResponder(resp *http.Response) (result SystemIncompleteLogStorageExecutionsResumeOKResponse, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // SystemInfoGet sends the system info get request.
    func (client BaseClient) SystemInfoGet(ctx context.Context) (result SystemInfo, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.SystemInfoGet")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.SystemInfoGetPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemInfoGet", nil , "Failure preparing request")
        return
        }

                resp, err := client.SystemInfoGetSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemInfoGet", resp, "Failure sending request")
                return
                }

                result, err = client.SystemInfoGetResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemInfoGet", resp, "Failure responding to request")
                }

        return
        }

        // SystemInfoGetPreparer prepares the SystemInfoGet request.
        func (client BaseClient) SystemInfoGetPreparer(ctx context.Context) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/system/info"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // SystemInfoGetSender sends the SystemInfoGet request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) SystemInfoGetSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // SystemInfoGetResponder handles the response to the SystemInfoGet request. The method always
    // closes the http.Response Body.
    func (client BaseClient) SystemInfoGetResponder(resp *http.Response) (result SystemInfo, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // SystemLogStorageInfoGet sends the system log storage info get request.
    func (client BaseClient) SystemLogStorageInfoGet(ctx context.Context) (result LogStorage, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.SystemLogStorageInfoGet")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.SystemLogStorageInfoGetPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemLogStorageInfoGet", nil , "Failure preparing request")
        return
        }

                resp, err := client.SystemLogStorageInfoGetSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemLogStorageInfoGet", resp, "Failure sending request")
                return
                }

                result, err = client.SystemLogStorageInfoGetResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemLogStorageInfoGet", resp, "Failure responding to request")
                }

        return
        }

        // SystemLogStorageInfoGetPreparer prepares the SystemLogStorageInfoGet request.
        func (client BaseClient) SystemLogStorageInfoGetPreparer(ctx context.Context) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/system/logstorage"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // SystemLogStorageInfoGetSender sends the SystemLogStorageInfoGet request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) SystemLogStorageInfoGetSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // SystemLogStorageInfoGetResponder handles the response to the SystemLogStorageInfoGet request. The method always
    // closes the http.Response Body.
    func (client BaseClient) SystemLogStorageInfoGetResponder(resp *http.Response) (result LogStorage, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // SystemScheduledJobsForServer sends the system scheduled jobs for server request.
        // Parameters:
            // UUID - the ID of the user to retrieve profile information for
    func (client BaseClient) SystemScheduledJobsForServer(ctx context.Context, UUID string) (result ListJob, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.SystemScheduledJobsForServer")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.SystemScheduledJobsForServerPreparer(ctx, UUID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemScheduledJobsForServer", nil , "Failure preparing request")
        return
        }

                resp, err := client.SystemScheduledJobsForServerSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemScheduledJobsForServer", resp, "Failure sending request")
                return
                }

                result, err = client.SystemScheduledJobsForServerResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemScheduledJobsForServer", resp, "Failure responding to request")
                }

        return
        }

        // SystemScheduledJobsForServerPreparer prepares the SystemScheduledJobsForServer request.
        func (client BaseClient) SystemScheduledJobsForServerPreparer(ctx context.Context, UUID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "uuid": autorest.Encode("path",UUID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/scheduler/server/{uuid}/jobs",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // SystemScheduledJobsForServerSender sends the SystemScheduledJobsForServer request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) SystemScheduledJobsForServerSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // SystemScheduledJobsForServerResponder handles the response to the SystemScheduledJobsForServer request. The method always
    // closes the http.Response Body.
    func (client BaseClient) SystemScheduledJobsForServerResponder(resp *http.Response) (result ListJob, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // SystemScheduledJobsList sends the system scheduled jobs list request.
    func (client BaseClient) SystemScheduledJobsList(ctx context.Context) (result ListJob, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.SystemScheduledJobsList")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.SystemScheduledJobsListPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemScheduledJobsList", nil , "Failure preparing request")
        return
        }

                resp, err := client.SystemScheduledJobsListSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemScheduledJobsList", resp, "Failure sending request")
                return
                }

                result, err = client.SystemScheduledJobsListResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemScheduledJobsList", resp, "Failure responding to request")
                }

        return
        }

        // SystemScheduledJobsListPreparer prepares the SystemScheduledJobsList request.
        func (client BaseClient) SystemScheduledJobsListPreparer(ctx context.Context) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/scheduler/jobs"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // SystemScheduledJobsListSender sends the SystemScheduledJobsList request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) SystemScheduledJobsListSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // SystemScheduledJobsListResponder handles the response to the SystemScheduledJobsList request. The method always
    // closes the http.Response Body.
    func (client BaseClient) SystemScheduledJobsListResponder(resp *http.Response) (result ListJob, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // SystemSchedulerTakeover sends the system scheduler takeover request.
    func (client BaseClient) SystemSchedulerTakeover(ctx context.Context, schedulerTakeoverRequest *SchedulerTakeoverRequest) (result TakeoverScheduleResponse, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.SystemSchedulerTakeover")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
                if err := validation.Validate([]validation.Validation{
                { TargetValue: schedulerTakeoverRequest,
                 Constraints: []validation.Constraint{	{Target: "schedulerTakeoverRequest", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "schedulerTakeoverRequest.Server", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "schedulerTakeoverRequest.Server.UUID", Name: validation.Null, Rule: true, Chain: nil },
                	{Target: "schedulerTakeoverRequest.Server.All", Name: validation.Null, Rule: true, Chain: nil },
                }},
                	{Target: "schedulerTakeoverRequest.Job", Name: validation.Null, Rule: false ,
                Chain: []validation.Constraint{	{Target: "schedulerTakeoverRequest.Job.ID", Name: validation.Null, Rule: true, Chain: nil },
                }},
                }}}}}); err != nil {
                return result, validation.NewError("rundeck.BaseClient", "SystemSchedulerTakeover", err.Error())
                }

                    req, err := client.SystemSchedulerTakeoverPreparer(ctx, schedulerTakeoverRequest)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemSchedulerTakeover", nil , "Failure preparing request")
        return
        }

                resp, err := client.SystemSchedulerTakeoverSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemSchedulerTakeover", resp, "Failure sending request")
                return
                }

                result, err = client.SystemSchedulerTakeoverResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "SystemSchedulerTakeover", resp, "Failure responding to request")
                }

        return
        }

        // SystemSchedulerTakeoverPreparer prepares the SystemSchedulerTakeover request.
        func (client BaseClient) SystemSchedulerTakeoverPreparer(ctx context.Context, schedulerTakeoverRequest *SchedulerTakeoverRequest) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPut(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/scheduler/takeover"))
                if schedulerTakeoverRequest != nil {
                preparer = autorest.DecoratePreparer(preparer,
                autorest.WithJSON(schedulerTakeoverRequest))
                }
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // SystemSchedulerTakeoverSender sends the SystemSchedulerTakeover request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) SystemSchedulerTakeoverSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // SystemSchedulerTakeoverResponder handles the response to the SystemSchedulerTakeover request. The method always
    // closes the http.Response Body.
    func (client BaseClient) SystemSchedulerTakeoverResponder(resp *http.Response) (result TakeoverScheduleResponse, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UserList sends the user list request.
    func (client BaseClient) UserList(ctx context.Context) (result ListUser, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UserList")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UserListPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "UserList", nil , "Failure preparing request")
        return
        }

                resp, err := client.UserListSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "UserList", resp, "Failure sending request")
                return
                }

                result, err = client.UserListResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "UserList", resp, "Failure responding to request")
                }

        return
        }

        // UserListPreparer prepares the UserList request.
        func (client BaseClient) UserListPreparer(ctx context.Context) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/user/list"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UserListSender sends the UserList request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UserListSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UserListResponder handles the response to the UserList request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UserListResponder(resp *http.Response) (result ListUser, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result.Value),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UserProfileGet sends the user profile get request.
    func (client BaseClient) UserProfileGet(ctx context.Context) (result User, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UserProfileGet")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UserProfileGetPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "UserProfileGet", nil , "Failure preparing request")
        return
        }

                resp, err := client.UserProfileGetSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "UserProfileGet", resp, "Failure sending request")
                return
                }

                result, err = client.UserProfileGetResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "UserProfileGet", resp, "Failure responding to request")
                }

        return
        }

        // UserProfileGetPreparer prepares the UserProfileGet request.
        func (client BaseClient) UserProfileGetPreparer(ctx context.Context) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/user/info"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UserProfileGetSender sends the UserProfileGet request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UserProfileGetSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UserProfileGetResponder handles the response to the UserProfileGet request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UserProfileGetResponder(resp *http.Response) (result User, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UserProfileGetByID sends the user profile get by id request.
        // Parameters:
            // userID - the ID of the user to retrieve profile information for
    func (client BaseClient) UserProfileGetByID(ctx context.Context, userID string) (result User, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UserProfileGetByID")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UserProfileGetByIDPreparer(ctx, userID)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "UserProfileGetByID", nil , "Failure preparing request")
        return
        }

                resp, err := client.UserProfileGetByIDSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "UserProfileGetByID", resp, "Failure sending request")
                return
                }

                result, err = client.UserProfileGetByIDResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "UserProfileGetByID", resp, "Failure responding to request")
                }

        return
        }

        // UserProfileGetByIDPreparer prepares the UserProfileGetByID request.
        func (client BaseClient) UserProfileGetByIDPreparer(ctx context.Context, userID string) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "userID": autorest.Encode("path",userID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/user/info/{userID}",pathParameters))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UserProfileGetByIDSender sends the UserProfileGetByID request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UserProfileGetByIDSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UserProfileGetByIDResponder handles the response to the UserProfileGetByID request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UserProfileGetByIDResponder(resp *http.Response) (result User, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UserProfileUpdate sends the user profile update request.
        // Parameters:
            // userParameter - new user profile data
    func (client BaseClient) UserProfileUpdate(ctx context.Context, userParameter ModifyUserRequest) (result User, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UserProfileUpdate")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UserProfileUpdatePreparer(ctx, userParameter)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "UserProfileUpdate", nil , "Failure preparing request")
        return
        }

                resp, err := client.UserProfileUpdateSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "UserProfileUpdate", resp, "Failure sending request")
                return
                }

                result, err = client.UserProfileUpdateResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "UserProfileUpdate", resp, "Failure responding to request")
                }

        return
        }

        // UserProfileUpdatePreparer prepares the UserProfileUpdate request.
        func (client BaseClient) UserProfileUpdatePreparer(ctx context.Context, userParameter ModifyUserRequest) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/user/info"),
        autorest.WithJSON(userParameter))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UserProfileUpdateSender sends the UserProfileUpdate request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UserProfileUpdateSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UserProfileUpdateResponder handles the response to the UserProfileUpdate request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UserProfileUpdateResponder(resp *http.Response) (result User, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UserProfileUpdateByID sends the user profile update by id request.
        // Parameters:
            // userID - the ID of the user to retrieve profile information for
            // userParameter - new user profile data
    func (client BaseClient) UserProfileUpdateByID(ctx context.Context, userID string, userParameter ModifyUserRequest) (result User, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UserProfileUpdateByID")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UserProfileUpdateByIDPreparer(ctx, userID, userParameter)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "UserProfileUpdateByID", nil , "Failure preparing request")
        return
        }

                resp, err := client.UserProfileUpdateByIDSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "UserProfileUpdateByID", resp, "Failure sending request")
                return
                }

                result, err = client.UserProfileUpdateByIDResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "UserProfileUpdateByID", resp, "Failure responding to request")
                }

        return
        }

        // UserProfileUpdateByIDPreparer prepares the UserProfileUpdateByID request.
        func (client BaseClient) UserProfileUpdateByIDPreparer(ctx context.Context, userID string, userParameter ModifyUserRequest) (*http.Request, error) {
                pathParameters := map[string]interface{} {
                "userID": autorest.Encode("path",userID),
                }

            preparer := autorest.CreatePreparer(
        autorest.AsContentType("application/json; charset=utf-8"),
        autorest.AsPost(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPathParameters("/user/info/{userID}",pathParameters),
        autorest.WithJSON(userParameter))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UserProfileUpdateByIDSender sends the UserProfileUpdateByID request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UserProfileUpdateByIDSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UserProfileUpdateByIDResponder handles the response to the UserProfileUpdateByID request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UserProfileUpdateByIDResponder(resp *http.Response) (result User, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

    // UserRoleList sends the user role list request.
    func (client BaseClient) UserRoleList(ctx context.Context) (result UserRoleListOKResponse, err error) {
        if tracing.IsEnabled() {
            ctx = tracing.StartSpan(ctx, fqdn + "/BaseClient.UserRoleList")
            defer func() {
                sc := -1
                if result.Response.Response != nil {
                    sc = result.Response.Response.StatusCode
                }
                tracing.EndSpan(ctx, sc, err)
            }()
        }
            req, err := client.UserRoleListPreparer(ctx)
        if err != nil {
        err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "UserRoleList", nil , "Failure preparing request")
        return
        }

                resp, err := client.UserRoleListSender(req)
                if err != nil {
                result.Response = autorest.Response{Response: resp}
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "UserRoleList", resp, "Failure sending request")
                return
                }

                result, err = client.UserRoleListResponder(resp)
                if err != nil {
                err = autorest.NewErrorWithError(err, "rundeck.BaseClient", "UserRoleList", resp, "Failure responding to request")
                }

        return
        }

        // UserRoleListPreparer prepares the UserRoleList request.
        func (client BaseClient) UserRoleListPreparer(ctx context.Context) (*http.Request, error) {
            preparer := autorest.CreatePreparer(
        autorest.AsGet(),
        autorest.WithBaseURL(client.BaseURI),
        autorest.WithPath("/user/roles"))
        return preparer.Prepare((&http.Request{}).WithContext(ctx))
        }

        // UserRoleListSender sends the UserRoleList request. The method will close the
        // http.Response Body if it receives an error.
        func (client BaseClient) UserRoleListSender(req *http.Request) (*http.Response, error) {
                return autorest.SendWithSender(client, req,
                autorest.DoRetryForStatusCodes(client.RetryAttempts, client.RetryDuration, autorest.StatusCodesForRetry...))
                }

    // UserRoleListResponder handles the response to the UserRoleList request. The method always
    // closes the http.Response Body.
    func (client BaseClient) UserRoleListResponder(resp *http.Response) (result UserRoleListOKResponse, err error) {
        err = autorest.Respond(
        resp,
        client.ByInspecting(),
        azure.WithErrorUnlessStatusCode(http.StatusOK),
        autorest.ByUnmarshallingJSON(&result),
        autorest.ByClosing())
        result.Response = autorest.Response{Response: resp}
            return
        }

